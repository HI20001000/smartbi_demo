# SmartBI Demo 流程說明（現況版）

本文依照目前程式碼實作，整理 SmartBI 專案中「`/normalize` 輸入 → 規則草稿 → LLM 補全（可選）→ 驗證」的完整流程，作為後續調整規則、Prompt 與 Schema 的參考。

---

## 1) 入口與執行模式

### 1.1 啟動入口

- `main.py` 只做一件事：呼叫 `run_cli()`。  
- 主要互動都在 `src/app.py` 的 CLI 迴圈中。

### 1.2 CLI 指令

`run_cli()` 目前支援：

- `/exit`：離開
- `/reset`：清空對話記憶
- `/history`：列出對話歷史
- `/normalize <text>`：觸發正規化流程

### 1.3 `/normalize` 呼叫前置

當使用者輸入 `/normalize ...` 時，CLI 會先組兩個 context：

- `request_context`
  - `request_id`（timestamp-based）
  - `request_ts`（含時區 ISO datetime）
  - `timezone`（預設 `Asia/Macau`）
  - `channel`（`cli`）
- `user_context`
  - `user_id`
  - `role`
  - `data_scope`
  - `allowed_regions`

此外，CLI 會：

- 建立 `llm_completion_client`（把 LangChain `invoke()` 轉成文字 completion 介面）
- 以 `debug=True` 呼叫 `normalize_input(...)`，因此會印出每個階段 JSON 與 diff

---

## 2) 正規化總流程（`normalize_input`）

`src/normalization/normalizer.py` 的 `normalize_input(...)` 目前是 **三階段 pipeline**：

1. `build_normalized_request(...)`：規則引擎先產生草稿（draft）
2. `enrich_draft(...)`：用 LLM 對草稿做受控補全（可關閉）
3. `validate_normalized_request(...)`：做 schema + 規則驗證

若驗證失敗，拋出 `NormalizationError("; ".join(errors))`。

---

## 3) 階段 A：規則引擎產生 draft

`build_normalized_request(...)`（`src/normalization/rule_engine.py`）步驟如下。

### 3.1 文字正規化 `_normalize_text`

- `strip()`
- 連續空白壓成單一空白
- 固定替換詞（目前如 `期末餘額 -> 存款餘額`、`transaction volume -> 交易量`）

### 3.2 語言判斷 `_detect_language`

- 含中文 Unicode 範圍字元 → `zh-TW`
- 否則 → `en`

### 3.3 意圖判斷 `_detect_intent`

以關鍵字規則分類：

- `detail_request`
- `trend`
- `comparison`
- `kpi_query`
- `out_of_scope`

### 3.4 時間解析 `parse_time_phrase`

呼叫 `src/normalization/time_parser.py`，回傳：

- `original_phrase`
- `resolved`（可能為 `None`）

若找不到時間片語，之後會補 `missing_required_fields: ["time_window"]`。

### 3.5 指標提示（Metric hints）

- 讀取 `semantic/metrics.yaml`（`load_metric_catalog`）
- 以 `retrieve_metric_hints` 做匹配
- 命中結果放在 `metric_hints`
- 若沒有命中，`missing_required_fields` 會加入 `metric`

### 3.6 風險旗標 `_risk_flags`

根據文字與時間結果產生：

- `pii_requested`
- `account_level_detail_requested`
- `customer_level_detail_requested`
- `missing_time_filter`
- `cross_currency_aggregation_risk`

並組出：

- `contains_sensitive_terms`
- `risk_flags`

### 3.7 Trace 與輸出

輸出 JSON 主結構包含：

- `schema_version`
- `request_id`
- `request_context`
- `user_context`
- `query_context`
- `time_context`
- `risk_context`
- `metric_hints`
- `normalization_trace`
- `missing_required_fields`

---

## 4) 階段 B：LLM 補全（`enrich_draft`）

`src/normalization/llm_enricher.py` 會在 **啟用且有 llm_client** 時運作，否則直接回傳原 draft。

### 4.1 何時啟用

- `ENABLE_LLM_COMPLETION`（預設 `true`）
- 且 `llm_client` 不為 `None`

### 4.2 Prompt 與輸入

- Prompt 模板來源：`prompts/json_completion_prompt.md`
- `build_json_completion_prompt(...)` 會把以下 payload 附在 Prompt 後面：
  - `draft`
  - `time_resolved`
  - `risk_flags`
  - `allowed_fields`
  - `protected_fields`

### 4.3 欄位保護與白名單

- 可改欄位：`LLM_COMPLETION_ALLOWED_FIELDS`
  - 預設：`query_context,time_context,metric_hints,filter_hints,missing_required_fields`
- 受保護欄位：`LLM_COMPLETION_PROTECTED_FIELDS`
  - 預設：`request_id,request_context,user_context,schema_version`

補全後會套用 `_enforce_allowed_and_protected(...)`：

- 只接受 allow-list 欄位覆寫
- protected 欄位強制還原原值

### 4.4 重試與失敗退回

- `LLM_COMPLETION_MAX_ATTEMPTS`：範圍限制在 1~2，預設 1
- 若發生以下任一狀況，會記錄失敗並嘗試下一輪（或最終 fallback）：
  - LLM 呼叫失敗 / JSON parse 失敗
  - 回傳缺少 `completed` 物件
  - 補全後驗證不通過
- 最終失敗時，回傳原始 draft（不拋錯）

---

## 5) 階段 C：驗證（`validate_normalized_request`）

`src/normalization/validator.py` 會載入 `contracts/normalized_request.schema.json`，再加上程式內規則檢查。

### 5.1 檢查重點

- 最上層 `required` keys 是否存在
- `schema_version == "1.0"`
- `request_context` 型別與必要欄位
- `query_context.language` / `query_context.intent` 是否在允許值
- `time_context.resolved` 結構與日期格式（`YYYY-MM-DD`）
- `missing_required_fields` 必須是 array

回傳 `(ok, errors)`；`ok=False` 時由 `normalize_input` 轉成 `NormalizationError`。

---

## 6) Debug 輸出（目前 CLI 預設開）

`normalize_input(..., debug=True)` 會印：

1. `build_normalized_request` 結果
2. `enrich_draft` 結果
3. `build -> enrich` 的欄位 diff path
4. `validate_normalized_request` 的 `{ok, errors, validated}`

有助於追「規則引擎產生了什麼」與「LLM 到底改了哪些欄位」。

---

## 7) 端到端摘要

目前實作可濃縮為：

1. CLI 收到 `/normalize`
2. 組 `request_context` / `user_context`
3. 規則引擎產生 draft
4. 依環境設定決定是否進行 LLM 補全
5. 套用 allow/protected 規則
6. 驗證 schema 與欄位合法性
7. 成功輸出 normalized JSON；失敗拋 `NormalizationError`

---

## 8) 目前維運上特別要注意

- `LLM_COMPLETION_ALLOWED_FIELDS` 預設含 `filter_hints`，但目前 rule-engine draft 不一定有此欄位；若要正式使用，建議在 schema 與流程中明確定義。  
- 驗證器是「讀 schema + 額外程式規則」雙軌，調整 schema 時要同步檢查 `validator.py`。  
- `/normalize` 分支完成後，CLI 目前仍會繼續執行一般聊天 `bot.invoke(...)`；若預期只做 normalize，可考慮在該分支 `continue`。
